from flask import Flask 
from app._cfg import ConfigWithErrorToGmail #2834
from flask_sqlalchemy import SQLAlchemy 
from flask_migrate import Migrate 
from flask_login import LoginManager

from flask_babel import Babel
from flask import request

# расширения должны быть созданы и инициализированы сразу после 
# экземпляра приложения в app/init.py

app = Flask(__name__)
app.config.from_object(ConfigWithErrorToGmail)
db = SQLAlchemy(app)
login = LoginManager(app)
# Flask-Login должен знать, какая вьюшка обрабатывает логины,
# чтобы при попытке зайти на защищенную стр. пользователь, если
# он не залогинен, перенаправлялся бы на страницу входа в систему
login.login_view = 'login'	# см описание в комментах к файлу с моделями БД (#5124)
# здесь значение 'login' это то же, что и url_for('login')
login.login_message = 'Выполни вход в аккаунт, чтобы посетить эту страницу'

migrate = Migrate(app, db)

# специально импортируем внизу - это обходной путь для циклического импорта
# т.к. он должен импортировать переменную приложения (app)
# определенную в этом скрипте

# из пакета app (так назвается папка в которой находится пакет)
# импортирует модуль routes
# (пакет определяется каталогом и скриптом __init__.py)
from app import routes, _models_bd, errors

# чтобы приложение запустилось с желаемыми параметрами:
# app.run(host='0.0.0.0', port=9079, debug=False)

babel = Babel(app)

# Экземпляр Babel предоставляет декоратор localeselector. 
# Декорированная функция вызывается для каждого запроса, 
# чтобы выбрать перевод языка для использования
@babel.localeselector
def get_locale():
	return request.accept_languages.best_match(app.config['LANGUAGES']) #1923
	# return 'en' # так можно заставить всегда считать английский самым предпочтительным языком
	# return 'ru' # а так русский

# ====================================================
# >>> from app.models import User
# >>> u = User(username='susan', email='susan@example.com')
# >>> u
# <User susan>

# ===================================================
#2834
# файл с конфигурациями все же лучше хранить не в составе
# пакета приложения, а на верхнем уровне, где расположен
# скрипт, запускающий проект

# =============================================#1923
# объект accept_languages обеспечивает интерфейс высокого уровня для работы с 
# заголовком Accept-Language, отправляемым клиентами с запросом. 
# Этот заголовок указывает язык клиента и языковые предпочтения 
# в виде средневзвешенного списка. Содержимое этого заголовка можно настроить 
# на странице настроек браузера, при этом по умолчанию обычно импортируются 
# из языковых настроек в операционной системе компьютера. 
# Большинство людей даже не знают, что такая настройка существует, но это полезно, 
# поскольку пользователи могут предоставить список предпочтительных языков, 
# каждый из которых имеет вес.
# пример сложного заголовка Accept-Languages:
# Accept-Language: da, en-gb;q=0.8, en;q=0.7
# Видим, что Датский (da) является предпочтительным языком (значение веса по умолчанию 1,0),
# а затем Британский английский (en-gb) с весом 0,8, и в качестве последнего 
# варианта Общий Английский (en) с весом 0,7.

# Чтобы выбрать лучший язык, нужно сравнить список языков, запрашиваемых клиентом, 
# с языками, которые поддерживает приложение, и, используя предоставленные клиентом веса,
# найти лучший язык. Возможно вам кажется эта логика слишком сложной, 
# но все это инкапсулируется в метод best_match(), который принимает список языков, 
# предлагаемых приложением в качестве аргумента и возвращает лучший выбор.

# ============================================

